# Z80 3chip構成の整理

Z80をはじめとするレトロCPUを最近のマイコンで動作させる、そういうレトロPC野郎は古くから居たのだが、最近、EMUZ80の登場により一層火が付いたように思う。

私もZ80を動かすのが好きなのでいくつかの試みを行ってきたが、EMUZ80のCLC活用に感動し、また同好の士の活躍をTwitterで目にすることが多くなり、それらに刺激されて、PICを使った技をいくつか試みた。

EMUZ80はZ80とPIC18F47Q43の2チップだけが基板に乗っかっており、その美しさが魅力だと思っている。だが、2チップ構成の場合、Z80プログラムを載せるRAMの容量がPICの内蔵RAM容量に制限されてしまう。また、Z80のメモリアクセスごとにWAITを入れて待たせる、またPICの実行速度の制約により数WAIT入ってしまう。実行速度上の限界が出てくる。

RAM容量の制約と実行速度の制約、この2つを打破するための方法の一つとして、2チップにSRAMを足して3チップ化するアプローチがある。私はこのアプローチに注力して基板を起こしファームを書き、現時点である程度の整理を得たように思う。そこで得たことをここに書き記しておこうと思う。

## 2チップ構成と3チップ構成

Z80を2チップ構成で動作させる場合、RAM(Z80が実行するプログラムとデータの置き場)をPIC内蔵RAM上に置く。よって、Z80のメモリアクセスはPIC側のプログラム処理で対応する。このとき、 1アクセス処理(アドレスを読み取ってデータバスにデータを置く/データバスからデータを読み取る)に数us掛かるため、通常はZ80のメモリアクセスを長くする。WAIT信号を使うかクロックを落とすかである。

いずれにしても、PIC内部の「アドレスバスを読み取ってデータバスに書き出す/読み込む」時間はPICソフトの処理時間であり、数usからの大幅な短縮は難しい。通常、Z80を2.5MHzや4MHzで駆動するとメモリアクセスは1us以下で完了するため、「遅いなぁ」という感覚は抜けない。

また、PIC内部のRAM容量が8kBから12kB程度と限られており、CP/Mを動かすには足りない。

RAM容量の限界と速度の限界を打破するための方法として、SRAMチップを加えて3チップ構成とする方法がある。Z80プログラム実行中はZ80とSRAMアクセスという従来の方式に基づいて動作するために、高速なSRAMを使用することで20MHzでも問題なく動作する。また、128kBのSRAMが100円以下で買えるので、お財布にも優しく64kBシステムを実現できる。3チップなら秋月B基板+αのサイズに載るので、基板作成もお安くできる。

以下、容量64kB/クロック20MHz、シリアルポートとSDcard I/F対応の基板・システム実現を念頭に置く。EMUZ80の良さである秋月B基板サイズに少数チップ搭載という性質にもこだわり、基板サイズは100mm x 100mm に収まるように考える。

## 3チップ構成で考えたこと(実現したいこと・実現アイディア)

3chip構成にするのは高速化と大容量RAM化のためなので、具体的には128kB SRAMチップを搭載し20MHz駆動を目指す。明示していないが、秋月電子通商で手に入る安価なLSIを使うことも考えている。

この手のSBCの動作としては、SRAM上にZ80プログラムを展開し、展開後RESETを解除してZ80の実行を開始する。シリアルポートとディスクアクセスはPIC端子にシリアルI/FとSDcardを接続し、Z80のI/O命令をPICプログラムで処理することで行う。すなわち、ブートローディングとI/OデバイスエミュレーションがPICの役割となる。
* ブートローディング: Z80プログラムをRAM上に展開する。PIC内部のフラッシュメモリにROMイメージを焼いておき、起動後にそれをRAM上に展開することが普通だが、毎回シリアル経由でダウンロードする方法も考慮に入れる。
* Z80のI/Oデバイスエミュレーション: シリアルとフロッピーディスクエミュレーション。シリアル経由で母艦のTeratermウインドウで実行する。フロッピーディスクエミュレートは、SDcardにフロッピーディスクイメージファイルを置き、その内部への512 バイト単位でのアクセスとして実現する。SDcardはSPI経由での接続とする。

PICで動く「モニタ」はシリアル経由のアップロード(RAM上への展開)とZ80実行開始コマンド程度に抑えておく。

回路は単純に抑える。Z80, SRAM, PICの3チップでできるだけ頑張る。シリアルやフロッピーエミュレーションなどの機能はPICにとりこむだけでなく、PICのCLC機能を活用することで外部のゲート回路をPIC内部に収容することができる。

## 2種類の基板

PIC18F47Q43 40ピンDIPを使う基板と、PIC18F57Q43 48ピンを使う基板の2種類を作成した。SRAMとの組み合わせも2種類あり、PIC18F47Q43とDIP32ピン128kB SRAMの組み合わせと、PIC18F57Q43と高速アクセスタイム15ns 32pin SOJ SRAM(HM678127UHJ-12)の組み合わせとした。前者をEMUPU_RAM40, 後者をEMUPU_RAM48と呼ぶ。

## I/O命令の実行

I/O命令はすべてPICが担当する。I/O命令を実行するとWAITサイクルに入りCPUを待たせておいて、PICのソフトウエアによりデバイス制御(シリアル読み込み/書き出し、SDカードセクタリードライト)を実行する。処理が完了したらWAITを解除してZ80の処理を継続させる。

実現は、IORQ/がアサートされるとWAIT/をアサートするようにする。ソフトでは間に合わないので、CLCのD-FFを用いてIORQ/の下りエッジでWAIT/がLになるようにしている。このあたりはEMUZ80と同じである。

## PICピンの割り当て

3チップ以外のチップを増やさないということは、PICのピンはZ80またはSRAMに直結するということになる。秋月電子通商からPIC18F47Q43(40pin DIP)と、PIC18F57Q43(48pin QFP)を入手することができる。

PIC18F47Q43のGPIOポートは、PA0-8, PB0-7, PC0-7, PD0-7, PE0-2の35本使うことができる。
* デバッガ2本: PB6,7
* シリアル2本: PA6,7
* データバス8本: PC0-7
* Z80制御信号11本: PA0-5, PE0-1, PD5-7
* SPI 4本: PD0-3
* TESTピン1本: PE2

これで28本、35本から差し引くとアドレスバスに割り当てる端子は7本しかない。実際にはPB6,7はアドレスバスとも兼用できるので最大9本割り当てできる。アドレスバスには8本割り当てる。

* アドレスバス8本(A0-A7): PB0-7

## SDカード用のPIC GPIO端子の割り当て

当初、SDカード用のSPI 4本は専用に割り当てているたが、その後の調査により方針を変更した。すなわち、SS以外の3本はデータバスと共通とし、MISOはSS(CS)がネゲート(H)のときはHi-Zとなるように3ステートバッファを噛ますという方針である。

最新の基板(Rev003)は上記の方針変更の前に製造指示を出してしまっていたので、4本専用割り当てとなっている。別途、ジャンパを飛ばして3本共通方式で動作を確認しておく。

SPI 4本のうちSSを除く3本をデータバスと兼用して動作させることができているという報告が上がっている。Z80実行中はSSをネゲート(Hにする)しておき、MISOをHi-Zにすることで動作するとのことである。

以前SDカードについて調査した時は、SS\==HでSCLKに72パルスを加えるとSDカードはリセット状態に入り、初期化シーケンスを構成する特定のコマンド(CMD0)しか受け付けなくなると理解していた。今回、改めて、[SD Specifications Part 1 Physical Layer Simplified Specification Version 9.00 August 22, 2022](https://www.sdcard.org/downloads/pls/pdf?p=Part1_Physical_Layer_Simplified_Specification_Ver9.00.jpg&f=Part1_Physical_Layer_Simplified_Specification_Ver9.00.pdf&e=EN_SS1_9)を調査した。その結果、72パルスでリセット状態うんぬんの記載が一切見つからない。「電源投入後はIdle modeに入り、ここでCMD0を受けつける」の記載しか見つからなかった。よって、CSをHにしている限りはSDカードの動作には影響しないと判断し、3本共有+MOSIのHi-Z制御という方針で進める。

> 大昔のSDカードの場合、「CSをLにしてSCLKに72パルス加える」が有効なものが残っているかもしれない。安定して動作しない場合は観念して新しいカードを買ってください。

RAM40, RAM48のRev003基板について、SPI端子の割り当ては以下の表の通りになっている。

|SDcard信号|RAM40基板|RAM48基板|
|--|--|--|
|SS|RD3|RB0|
|MOSI|RD2|RB1|
|MISO|RD1|RB2|
|SCLK|RD0|RB3|
||||

3本共通とする場合、データバスD0-D3を使用する。両基板ともRC0-RC2を割り当てる。

|SDcard信号|RAM40基板|RAM48基板|
|--|--|--|
|SS|RD3|RB0|
|MOSI|RC0|RC0|
|MISO|RD1|RC1|
|SCLK|RD2|RC2|
||||

回路図(PIC端子割り当て)上のPIC端子順に合わせて配線した結果、RAM40基板とRAM48基板とで昇順が逆順になってしまっている。みっともないが、SPIモジュールとGPIOの割り当ての自由度は高いのでなんとかなるだろう。

## アドレスバス8本でSRAMにZ80プログラムを展開する方法

PICからSRAMにデータを書き込むには、アドレスバスに書き込みアドレスを、データバスにデータを出力して、CS/, WE/をH->L->HとLパルスを発生させればよい。SRAMは64kB使用するので任意の場所に書き込むためにはアドレスバス16本に書き込みアドレスを出力する必要がある。

では、アドレスバス8本だけでどうやって16本分と同じ働きをさせるのか?

Z80はSRAMに対してアドレスバス16本すべてつながっている。とすると、Z80にアドレス、データを出力させMREQ/, WE/にLパルスを送り込めばよい。というかこの方法しかない。

Z80がメモリ書き込みサイクルを実行するとSRAMに対して上記の処理を行うことになる。例えば、FA00h 番地に C3を書き込もうとする場合、

```
21 00FA   LD HL, FA00h
36 C3     LD (HL), C3h
```
という2命令をZ80に実行させればよい。具体的には以下の2つの方法が考えられる。

1. 0番地から順に上記5バイトを置き、リセットを解除する。
2. リセット解除後最初のインストラクションフェッチでSRAMからのデータ出力を邪魔してPICがデータバスに上記5バイトを順に置いてゆく(命令置き)。

命令置きのためには、メモリアクセスサイクルでWAITを掛けることと、メモリライトサイクルではSRAMを有効にすること(逆にPICはデータバスに出力せずHi-Z状態になること)が必要になる。

今回の試作では1の方法を用いた。上記5バイトに加え、その後ろに実行完了を表す命令(IN命令を使っている)2倍とも含め0番地から7バイト置いてからリセットを解除している。これを1バイト書き込むごとに行っている。

この7バイトの書き込みはPICからアドレス出力している。よって、最低でもA0-A2の3本はPICのGPIOにつないでおく必要がある。今回は8本あるので十分間に合っている。

2はかの名作[Z80-MBC2](https://j4f.info/z80-mbc2)が採用している方法である。命令置きの場合、SRAMに7バイトを展開する必要もない。PICはアドレスバスを使う必要がなく、I/Oアドレス用途以外にアドレスピンをつないでおく必要もない。Z80-MBC2では徹底していて、PICにはアドレスバスは1本(A0)しかつながっていない([回路図](https://j4f.info/_media/z80-mbc2/a040618_sch.pdf))。この方式ならば40ピンPICも要らない、28ピンPICで試作したという報告も上がっている。

## 間接接続

Z80とSRAMの間の信号OE/, WE/ をZ80 のRD/, WR/と直結せずに、PICにOE/, WE/をつなぐ方法もある。PICではCLCを2個用いて、Z80のMREQ/, RD/からOE/, WE/を発生する。

このやり方は奥江さんに教えてもらいました([SuperMEZ80](https://github.com/satoshiokue/SuperMEZ80))。この方法は、Z80がプログラム実行中もメモリアクセスを検出して待たせることができるので、いろいろ仕込みをいれる可能性があって楽しいのです。間接接続ならば命令置きも簡単に実現できます。MREQ/アサートもWAIT発生条件に追加し、ReadサイクルでOE/をアサートしないように(Hのままに)貼り付けておけばよい。

直接接続の場合は、SRAMがCS2を持つチップの場合、PICがCS2をコントロールすることでReadサイクルでSRAMを止めることができます。32ピンSRAMの場合、CSを2本持つものと1本しか持たないものがあるため、CSを2本持つSRAMを使い、かつ、CS2(31ピン)をPICのGPIO端子につなぐことで命令置きが実現できます。

話を関節接続に戻します。しかし、この方法ではSRAMのOE/, WE/がZ80がRD/を出してから50ns遅延することが分かった。実際に16MHzでは動作しない、SRAM OE/が間に合っていなかった。SRAMがデータを出力し始める時点でZ80はリードサイクルを終えてしまっていた。

クロック8MHz以下なら確実に動作するので、他のCPUをつないで動かすときには有益だろう。ということで、間接接続に切り替えることができるようにジャンパパターンを入れておいた(JP1,2,3)

